/*
 * Copyright (c) 2024 EdgeImpulse Inc.
 *
 * Generated by Edge Impulse and licensed under the applicable Edge Impulse
 * Terms of Service. Community and Professional Terms of Service
 * (https://docs.edgeimpulse.com/page/terms-of-service) or Enterprise Terms of
 * Service (https://docs.edgeimpulse.com/page/enterprise-terms-of-service),
 * according to your product plan subscription (the “License”).
 *
 * This software, documentation and other associated files (collectively referred
 * to as the “Software”) is a single SDK variation generated by the Edge Impulse
 * platform and requires an active paid Edge Impulse subscription to use this
 * Software for any purpose.
 *
 * You may NOT use this Software unless you have an active Edge Impulse subscription
 * that meets the eligibility requirements for the applicable License, subject to
 * your full and continued compliance with the terms and conditions of the License,
 * including without limitation any usage restrictions under the applicable License.
 *
 * If you do not have an active Edge Impulse product plan subscription, or if use
 * of this Software exceeds the usage limitations of your Edge Impulse product plan
 * subscription, you are not permitted to use this Software and must immediately
 * delete and erase all copies of this Software within your control or possession.
 * Edge Impulse reserves all rights and remedies available to enforce its rights.
 *
 * Unless required by applicable law or agreed to in writing, the Software is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing
 * permissions, disclaimers and limitations under the License.
 */
// Generated on: 16.10.2024 23:14:33

#include <stdio.h>
#include <stdlib.h>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "edge-impulse-sdk/porting/ei_classifier_porting.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#if defined (__GNUC__)  /* GNU compiler */
#define ALIGN(X) __attribute__((aligned(X)))
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (_MSC_VER)
#define ALIGN(X) __declspec(align(X))
#elif defined (__TASKING__) /* TASKING Compiler */
#define ALIGN(X) __align(X)
#define DEFINE_SECTION(x) __attribute__(section(x)))
#elif defined (__ARMCC_VERSION) /* Arm Compiler */
#define ALIGN(X) __ALIGNED(x)
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (__ICCARM__) /* IAR Compiler */
#define ALIGN(x) __attribute__((aligned(x)))
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (__clang__) /* LLVM/Clang Compiler */
#define ALIGN(X) __ALIGNED(x)
#define DEFINE_SECTION(x) __attribute__((section(x)))
#endif

#ifndef EI_MAX_SCRATCH_BUFFER_COUNT
#ifndef CONFIG_IDF_TARGET_ESP32S3
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#else
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#endif // CONFIG_IDF_TARGET_ESP32S3
#endif // EI_MAX_SCRATCH_BUFFER_COUNT

#ifndef EI_MAX_OVERFLOW_BUFFER_COUNT
#define EI_MAX_OVERFLOW_BUFFER_COUNT 10
#endif // EI_MAX_OVERFLOW_BUFFER_COUNT

using namespace tflite;
using namespace tflite::ops;
using namespace tflite::ops::micro;

namespace {

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX) || defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
constexpr int kTensorArenaSize = 1584;
#else
constexpr int kTensorArenaSize = 560;
#endif

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
#if defined (EI_TENSOR_ARENA_LOCATION)
#define STRINGIZE(x) #x
#define STRINGIZE_VALUE_OF(x) STRINGIZE(x)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) DEFINE_SECTION(STRINGIZE_VALUE_OF(EI_TENSOR_ARENA_LOCATION));
#else
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#endif
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};

enum used_operators_e {
  OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};

struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
};

typedef struct {
  TfLiteTensor tensor;
  int16_t index;
} TfLiteTensorWithIndex;

typedef struct {
  TfLiteEvalTensor tensor;
  int16_t index;
} TfLiteEvalTensorWithIndex;

TfLiteContext ctx{};
static const int MAX_TFL_TENSOR_COUNT = 4;
static TfLiteTensorWithIndex tflTensors[MAX_TFL_TENSOR_COUNT];
static const int MAX_TFL_EVAL_COUNT = 4;
static TfLiteEvalTensorWithIndex tflEvalTensors[MAX_TFL_EVAL_COUNT];
TfLiteRegistration registrations[OP_LAST];

namespace g0 {
const TfArray<2, int> tensor_dimension0 = { 2, { 1,39 } };
const ALIGN(16) float tensor_data1[10] = { 0.18125519156455994, 0.0019297815160825849, -0.040413521230220795, -0.13643643260002136, -0.12740679085254669, 0.10697181522846222, -0.0041377977468073368, 0.24557244777679443, 0.088819421827793121, -0.020462937653064728, };
const TfArray<1, int> tensor_dimension1 = { 1, { 10 } };
const ALIGN(16) float tensor_data2[20] = { 0.1055210679769516, 0.1627354770898819, -0.1686299741268158, 0.3202785849571228, -0.023905528709292412, 0.038044892251491547, 0.20075628161430359, -0.23598985373973846, 0.23888647556304932, -0.054067365825176239, -0.032301928848028183, 0.053574133664369583, 0.28345340490341187, 0.038971923291683197, -0.14660975337028503, -0.023496424779295921, -0.027344314381480217, -0.036020908504724503, 0.018782621249556541, 0.056920725852251053, };
const TfArray<1, int> tensor_dimension2 = { 1, { 20 } };
const ALIGN(16) float tensor_data3[4] = { -0.16611588001251221, 0.21899005770683289, -0.052347589284181595, -0.033150017261505127, };
const TfArray<1, int> tensor_dimension3 = { 1, { 4 } };
const ALIGN(16) float tensor_data4[20*39] = { 
  -0.064979739487171173, 0.099911026656627655, 0.025822259485721588, 0.29521289467811584, 0.045577168464660645, 0.26055040955543518, 0.30192992091178894, 0.23010876774787903, 0.32226023077964783, -0.064065851271152496, 0.089252270758152008, 0.23377107083797455, -0.25909128785133362, -0.23355843126773834, -0.27802455425262451, 0.31783598661422729, 0.092158213257789612, 0.1424250602722168, 0.021651620045304298, -0.084613889455795288, 0.32963570952415466, -0.064271338284015656, 0.33028548955917358, 0.061148561537265778, -0.22477656602859497, 0.24727450311183929, -0.3197406530380249, -0.027334421873092651, -0.48876363039016724, -0.142327681183815, 0.25257909297943115, 0.22185124456882477, 0.18131144344806671, -0.29280540347099304, -0.30977943539619446, 0.15990357100963593, -0.10898745805025101, 0.29397338628768921, 0.017901802435517311, 
  -0.16429540514945984, 0.002266682917252183, 0.22177992761135101, 0.19820685684680939, 0.041306909173727036, 0.25246185064315796, 0.25833189487457275, 0.38490873575210571, 0.29507580399513245, 0.39420637488365173, -0.13228394091129303, 0.15814381837844849, -0.054266393184661865, 0.19666106998920441, 0.10295910388231277, -0.21018831431865692, 0.35527411103248596, 0.22088485956192017, 0.44972604513168335, -0.11802302300930023, 0.050180602818727493, 0.054806757718324661, 0.32492628693580627, -0.055908430367708206, 0.18881054222583771, 0.1130131408572197, 0.033348262310028076, 0.44828832149505615, -0.098915383219718933, -0.010311883874237537, 0.20831437408924103, 0.48401600122451782, 0.37460625171661377, 0.38473781943321228, 0.2880074679851532, 0.015832236036658287, -0.12871187925338745, 0.0085355369374155998, 0.1427510529756546, 
  0.32188764214515686, -0.064868651330471039, -0.39723670482635498, -0.27470710873603821, 0.23108561336994171, -0.20421537756919861, 0.067234449088573456, 0.0075534754432737827, 0.20646406710147858, -0.07112952321767807, -0.2041219025850296, 0.074537329375743866, -0.1595919132232666, 0.2424054890871048, -0.016718192026019096, 0.17338025569915771, 0.013898283243179321, 0.19995774328708649, -0.12493188679218292, 0.062278229743242264, 0.2466806173324585, -0.30024996399879456, 0.11537402123212814, -0.22984607517719269, 0.019485296681523323, -0.092508003115653992, 0.37563988566398621, 0.14867393672466278, -0.11813917756080627, -0.34240043163299561, -0.16415785253047943, 0.12191130965948105, 0.17172951996326447, -0.20461922883987427, -0.063225232064723969, -0.13722972571849823, -0.38787263631820679, -0.12198862433433533, 0.085053056478500366, 
  -0.36833459138870239, 0.16282635927200317, -0.033037755638360977, 0.36135315895080566, -0.091221466660499573, 0.28930720686912537, 0.2546410858631134, 0.60451763868331909, 0.3829229474067688, -0.041574932634830475, 0.27637293934822083, 0.32513746619224548, 0.32225582003593445, 0.073870465159416199, -0.043056167662143707, -0.12489403039216995, 0.037103328853845596, 0.024853330105543137, 0.36923369765281677, 0.41986832022666931, -0.068560056388378143, 0.12690091133117676, -0.14902548491954803, -0.17010214924812317, 0.12724557518959045, 0.21547366678714752, -0.50639557838439941, -0.22664430737495422, 0.23965789377689362, 0.34517431259155273, -0.28498139977455139, 0.12883126735687256, 0.23975925147533417, -0.18937091529369354, 0.11753928661346436, -0.088845632970333099, 0.24329008162021637, -0.24662670493125916, 0.075048103928565979, 
  0.20102259516716003, 0.10173077881336212, 0.10719326138496399, -0.23108802735805511, -0.28765296936035156, -0.31568148732185364, 0.17450526356697083, -0.17417746782302856, -0.25109556317329407, 0.081611834466457367, -0.1960231214761734, -0.037754125893115997, -0.29429736733436584, -0.18165640532970428, -0.065042875707149506, 0.35116380453109741, 0.14279283583164215, 0.15493825078010559, -0.091524861752986908, -0.14416025578975677, -0.10827450454235077, 0.23102805018424988, -0.12221889942884445, -0.084796644747257233, -0.12389817833900452, -0.003421055618673563, 0.16822825372219086, 0.16855168342590332, -0.18101894855499268, -0.28369763493537903, 0.10493361204862595, -0.28161320090293884, 0.19296620786190033, -0.29880070686340332, -0.15003903210163116, -0.20160220563411713, -0.11956258118152618, -0.31018534302711487, 0.05099765956401825, 
  0.0067990170791745186, 0.26445445418357849, 0.058734048157930374, 0.054990433156490326, -0.024865342304110527, -0.13498438894748688, 0.055856268852949142, 0.48352956771850586, -0.07798207551240921, 0.075413256883621216, -0.24718038737773895, -0.099788159132003784, -0.43620476126670837, 0.19346944987773895, 0.068150684237480164, 0.063892565667629242, -0.28165563941001892, 0.072279177606105804, -0.093855023384094238, -0.026570612564682961, -0.23046259582042694, -0.2246597558259964, -0.029116168618202209, -0.17316290736198425, 0.24926301836967468, -0.1380460113286972, 0.18691147863864899, 0.4002145528793335, -0.25606635212898254, 0.47797748446464539, 0.21757875382900238, 0.14104859530925751, 0.32557496428489685, -0.11808127909898758, 0.14502744376659393, -0.16547486186027527, 0.33696508407592773, -0.15803305804729462, 0.18638746440410614, 
  0.15757592022418976, -0.25118142366409302, -0.12334989756345749, -0.017800420522689819, -0.11724008619785309, -0.23831936717033386, 0.021503297612071037, 0.22884644567966461, -0.071082927286624908, 0.071123294532299042, -0.031689688563346863, -0.035146601498126984, 0.10368757694959641, 0.15787865221500397, 0.07087881863117218, -0.12484563887119293, 0.084145292639732361, 0.028589164838194847, 0.47087720036506653, 0.43671953678131104, -0.015968641266226768, 0.12528204917907715, -0.068495094776153564, 0.25121718645095825, -0.11840645223855972, 0.044964015483856201, 0.3596586287021637, -0.67133891582489014, 0.31735318899154663, 0.11819339543581009, 0.0053158020600676537, -0.29949909448623657, 0.048576924949884415, 0.0063087339513003826, -0.20810119807720184, 0.14951767027378082, -0.31476753950119019, 0.17521843314170837, -0.20324152708053589, 
  0.43285933136940002, -0.41078472137451172, 0.022893354296684265, 0.16544023156166077, 0.33864074945449829, 0.049461711198091507, -0.1137654036283493, -0.22992704808712006, -0.25637999176979065, 0.12993767857551575, -0.064539939165115356, 0.26548662781715393, -0.060719285160303116, 0.29873931407928467, -0.015928298234939575, -0.31921222805976868, -0.24110975861549377, -0.16114187240600586, -0.39120689034461975, 0.19898641109466553, 0.20312085747718811, -0.14716535806655884, -0.19687579572200775, 0.080926947295665741, -0.011965447105467319, 0.30782109498977661, 0.063035376369953156, 0.18486176431179047, -0.16596587002277374, -0.20449639856815338, -0.0031262550037354231, 0.23433215916156769, 0.10874693095684052, -0.21820114552974701, -0.077442117035388947, -0.28992447257041931, -0.17011334002017975, -0.026611858978867531, 0.14035700261592865, 
  0.073000267148017883, 0.24520984292030334, 0.25832283496856689, 0.04746926948428154, -0.33234110474586487, 0.23548299074172974, 0.12718246877193451, 0.045112807303667068, 0.07425013929605484, 0.028173541650176048, -0.001339693320915103, 0.19758665561676025, 0.16302374005317688, -0.22690868377685547, -0.076505810022354126, -0.15437190234661102, 0.29266586899757385, -0.097517475485801697, 0.51036584377288818, 0.20807768404483795, 0.38581186532974243, 0.22664338350296021, 0.36984419822692871, 0.13726161420345306, 0.21280421316623688, 0.29488480091094971, 0.047469325363636017, -0.25182902812957764, 0.21545049548149109, -0.14302833378314972, 0.184528648853302, -0.26837584376335144, -0.10322467237710953, -0.062818542122840881, -0.27297204732894897, -0.1290457546710968, -0.17454239726066589, 0.39699190855026245, -0.092046149075031281, 
  -0.37830999493598938, 0.16555561125278473, -0.15053689479827881, -0.088901542127132416, -0.22327257692813873, 0.11288706958293915, -0.35558739304542542, -0.061103884130716324, -0.22130276262760162, -0.34882408380508423, -0.29224032163619995, -0.23928642272949219, -0.36106008291244507, -0.18850986659526825, -0.059483759105205536, 0.19447371363639832, -0.075490549206733704, 0.17532432079315186, 0.13614481687545776, -0.29072821140289307, -0.14702653884887695, 0.12564277648925781, -0.010711004957556725, 0.21936503052711487, 0.24749720096588135, 0.14045728743076324, -0.10030621290206909, 0.050021357834339142, 0.073523148894309998, 0.075322069227695465, -0.1757471114397049, -0.17348398268222809, -0.2980654239654541, -0.066111087799072266, 0.16885733604431152, 0.055318184196949005, 0.15803378820419312, 0.17263644933700562, -0.11666060239076614, 
  0.47663396596908569, 0.17371460795402527, 0.069754697382450104, -0.20635011792182922, -0.075981795787811279, -0.020525678992271423, 0.24042503535747528, 0.081451565027236938, 0.072151660919189453, 0.21354691684246063, -0.11099782586097717, 0.19365411996841431, 0.19938202202320099, -0.26190909743309021, -0.12299874424934387, -0.12482421845197678, -0.0042163161560893059, 0.046673312783241272, 0.072432778775691986, 0.066156275570392609, -0.21736995875835419, 0.1753620058298111, -0.30967378616333008, 0.21286411583423615, 0.22583039104938507, -0.11013887822628021, -0.059464778751134872, 0.0096228402107954025, 0.2098720520734787, 0.25860145688056946, -0.22097504138946533, -0.20092229545116425, -0.083891049027442932, 0.073930978775024414, 0.36122721433639526, 0.35399940609931946, -0.10601264983415604, -0.24777503311634064, -0.2633134126663208, 
  0.15558178722858429, -0.045837689191102982, 0.22604477405548096, 0.04657759889960289, -0.030416334047913551, -0.16437262296676636, 0.2933056652545929, -0.32684949040412903, 0.11756028980016708, -0.18730947375297546, 0.19514091312885284, 0.14622515439987183, 0.1699841320514679, 0.45313364267349243, -0.0042167287319898605, 0.075574703514575958, -0.02941250242292881, 0.042545657604932785, 0.31410884857177734, 0.10602746158838272, 0.035188797861337662, 0.046330902725458145, 0.32540345191955566, 0.062782041728496552, 0.085278376936912537, 0.1021701991558075, 0.51780474185943604, -0.12108069658279419, 0.46478989720344543, 0.17500440776348114, 0.021745422855019569, 0.0012941221939399838, 0.15821054577827454, 0.034092675894498825, 0.20470321178436279, -3.8441117794718593e-05, -0.28478360176086426, 0.0049881367012858391, 0.067011512815952301, 
  -0.19620539247989655, -0.31629613041877747, 0.10381805896759033, 0.11093951761722565, 0.24783912301063538, -0.20916680991649628, -0.096355780959129333, -0.19562773406505585, -0.22544284164905548, 0.14090704917907715, -0.1436452716588974, -0.35496953129768372, 0.013263657689094543, -0.0062674274668097496, -0.077709190547466278, 0.30484691262245178, 0.25250470638275146, -0.030141443014144897, 0.36744669079780579, 0.016969963908195496, 0.19642364978790283, 0.11230683326721191, -0.29639905691146851, 0.051338426768779755, 0.0057341582141816616, -0.23143444955348969, -0.11732974648475647, -0.35266885161399841, 0.38248348236083984, 0.08486764132976532, -0.17063155770301819, 0.037492450326681137, -0.39737924933433533, 0.17418546974658966, 0.10641559213399887, 0.11408831179141998, 0.19249342381954193, -0.23478880524635315, -0.26988118886947632, 
  0.17280226945877075, -0.39058932662010193, -0.14002950489521027, 0.022846374660730362, 0.32109382748603821, 0.32768473029136658, -0.24445757269859314, 0.29129663109779358, -0.037174377590417862, 0.082740552723407745, 0.055845294147729874, 0.088262230157852173, 0.28387650847434998, 0.027482930570840836, -0.23843048512935638, -0.037258550524711609, -0.29007285833358765, -0.041306730359792709, -0.28440400958061218, -0.17195194959640503, -0.28362801671028137, -0.29688221216201782, -0.057623472064733505, -0.14340543746948242, -0.17936749756336212, -0.37084293365478516, -0.17829841375350952, 0.23016965389251709, -0.0455351322889328, 0.053307518362998962, 0.11432802677154541, -0.34196186065673828, -0.28007775545120239, -0.33269000053405762, -0.065834455192089081, 0.045805592089891434, 0.097283296287059784, -0.054097499698400497, 0.21737261116504669, 
  0.35860824584960938, -0.42262634634971619, -0.21892829239368439, 0.0029807889368385077, 0.059944704174995422, -0.25588342547416687, -0.26677906513214111, -0.13884498178958893, 0.027091275900602341, 0.0091827884316444397, 0.24421945214271545, -0.38288226723670959, -0.28723505139350891, 0.41856279969215393, -0.070452310144901276, -0.12783598899841309, -0.33917629718780518, 0.078389734029769897, 0.060041557997465134, -0.29417267441749573, 0.22331783175468445, 0.29262286424636841, -0.21586063504219055, 0.21839772164821625, -0.34451639652252197, -0.22632612287998199, 0.13295240700244904, -0.30545422434806824, 0.36939528584480286, -0.23982051014900208, 0.1713651716709137, -0.22863417863845825, -0.10036514699459076, 0.25065809488296509, -0.017974574118852615, -0.20761322975158691, -0.30230081081390381, 0.046979986131191254, 0.22772043943405151, 
  -0.034132659435272217, 0.3403264582157135, -0.082451067864894867, -0.31270191073417664, -0.29395157098770142, 0.028501663357019424, -0.10554055869579315, -0.021649619564414024, 0.038988400250673294, 0.036561965942382812, -0.082844078540802002, 0.085032179951667786, -0.23393391072750092, 0.10196878015995026, 0.26153531670570374, 0.26070064306259155, 0.033191405236721039, 0.12108174711465836, 0.065539397299289703, 0.13710799813270569, -0.34324899315834045, 0.20603145658969879, -0.31406623125076294, 0.083322256803512573, 0.021753925830125809, -0.043190773576498032, -0.19024600088596344, -0.14612528681755066, -0.077613696455955505, -0.1796855628490448, 0.11797206848859787, -0.15909025073051453, -0.16011486947536469, 0.13270761072635651, -0.041589893400669098, 0.04137137159705162, -0.026830321177840233, -0.32596278190612793, 0.060162626206874847, 
  -0.030895540490746498, -0.28479933738708496, -0.15213210880756378, -0.061498802155256271, 0.22154194116592407, -0.042449124157428741, -0.069734908640384674, -0.18837404251098633, 0.14971928298473358, -0.24731449782848358, -0.24658742547035217, -0.07308003306388855, 0.10444775968790054, 0.06726614385843277, -0.22437286376953125, 0.087198980152606964, -0.33526968955993652, -0.29215693473815918, 0.1687643826007843, -0.064417049288749695, -0.22526644170284271, -0.15001462399959564, 0.15060411393642426, -0.10680150240659714, 0.1593342125415802, -0.077702470123767853, 0.014597329311072826, 0.2758442759513855, -0.24162730574607849, 0.18971118330955505, 0.067037768661975861, 0.049446426331996918, 0.29451113939285278, -0.14479060471057892, -0.047649171203374863, -0.11838283389806747, 0.14172881841659546, -0.21874161064624786, -0.092525698244571686, 
  -0.085111185908317566, 0.21864141523838043, 0.32523080706596375, 0.17843551933765411, 0.18230733275413513, -0.1639082133769989, -0.19358417391777039, 0.1950305700302124, 0.03722836822271347, -0.11276297271251678, -0.18649391829967499, 0.23496367037296295, -0.19545440375804901, 0.16887272894382477, -0.15612727403640747, 0.045682601630687714, -0.26558750867843628, 0.034166716039180756, 0.22008207440376282, -0.25172242522239685, 0.091540560126304626, -0.21382960677146912, -0.31628906726837158, 0.22753527760505676, -0.25780689716339111, -0.33636623620986938, -0.1812177300453186, 0.1621740311384201, 0.050633206963539124, -0.19930264353752136, -0.025535175576806068, -0.2909904420375824, -0.046294715255498886, 0.02051357738673687, -0.043322153389453888, 0.23833437263965607, 0.23739302158355713, -0.23660005629062653, 0.13347785174846649, 
  -0.2871377170085907, -0.069995172321796417, 0.17201244831085205, -0.29626870155334473, 0.1521274745464325, 0.0036791153252124786, -0.22917306423187256, -0.052339337766170502, -0.031275529414415359, -0.13421547412872314, -0.31515210866928101, -0.14328552782535553, -0.29267099499702454, -0.25667408108711243, -0.22523565590381622, -0.16759768128395081, 0.033731382340192795, -0.18257658183574677, -0.19751355051994324, 0.096685804426670074, -0.18090721964836121, 0.23908647894859314, -0.19624264538288116, 0.22582660615444183, -0.16114585101604462, -0.2992275059223175, -0.005082844290882349, -0.090254984796047211, -0.28908857703208923, -0.20018588006496429, 0.16594614088535309, -0.16148968040943146, -0.22435840964317322, -0.30906736850738525, 0.28832408785820007, 0.22570651769638062, 0.062452755868434906, -0.23832207918167114, -0.26910960674285889, 
  -0.014885805547237396, 0.25725710391998291, 0.054908659309148788, -0.11605304479598999, -0.083573229610919952, -0.1662190705537796, 0.03533497080206871, -0.10045534372329712, 0.17042477428913116, 0.15832160413265228, -0.31149160861968994, 0.19544333219528198, 0.16116885840892792, -0.0045284051448106766, 0.0047192983329296112, -0.052643131464719772, 0.034401163458824158, -0.28548282384872437, -0.22537896037101746, 0.031664136797189713, -0.17083808779716492, -0.34014511108398438, 0.19854086637496948, -0.29993313550949097, -0.072641089558601379, -0.046610895544290543, -0.17678141593933105, -0.13018190860748291, 0.1890413910150528, 0.29867264628410339, -0.191300168633461, -0.0029147483874112368, 0.22024437785148621, -0.2444581538438797, -0.019309036433696747, 0.064824812114238739, -0.33211991190910339, 0.025611709803342819, -0.026696018874645233, 
};
const TfArray<2, int> tensor_dimension4 = { 2, { 20,39 } };
const ALIGN(16) float tensor_data5[10*20] = { 
  0.21994419395923615, -0.22047650814056396, -0.1948731392621994, 0.42909502983093262, 0.43028002977371216, -0.019550390541553497, 0.59102201461791992, -0.38757151365280151, 0.16654641926288605, -0.11849462240934372, 0.24690985679626465, 0.14174216985702515, 0.34553182125091553, 0.50102508068084717, 0.22423917055130005, -0.25452062487602234, -0.0065533309243619442, -0.051543015986680984, -0.23527325689792633, 0.1999630331993103, 
  -0.11086765676736832, -0.51862585544586182, 0.240611732006073, 0.1384156197309494, 0.35217419266700745, 0.0053818649612367153, -0.24596810340881348, -0.38504171371459961, -0.31847038865089417, 0.15914863348007202, -0.12565211951732635, -0.14209860563278198, 0.35465964674949646, 0.13356535136699677, 0.28249391913414001, 0.45013591647148132, -0.12209439277648926, 0.27129840850830078, -0.082040175795555115, 0.066157817840576172, 
  -0.10238249599933624, -0.4180794358253479, -0.036072995513677597, 0.36575391888618469, -0.19911603629589081, -0.23186008632183075, -0.16760970652103424, 0.055924627929925919, -0.18013615906238556, -0.055254604667425156, 0.10937675833702087, 0.17582951486110687, -0.097098752856254578, -0.38061550259590149, -0.075818814337253571, -0.2809939980506897, 0.3033415675163269, -0.38157466053962708, -0.38322222232818604, -0.32131925225257874, 
  -0.25165408849716187, -0.029905740171670914, 0.58448207378387451, -0.11553274095058441, -0.20401833951473236, 0.24928458034992218, -0.069810338318347931, -0.011820214800536633, -0.29747840762138367, 0.28389477729797363, 0.61629647016525269, 0.31792530417442322, -0.36992630362510681, -0.21964806318283081, 0.26677396893501282, -0.1549447625875473, -0.14485113322734833, -0.16098465025424957, 0.43513810634613037, 0.37393683195114136, 
  -0.41330903768539429, 0.18191549181938171, -0.18113093078136444, -0.43239662051200867, -0.25465613603591919, 0.48863238096237183, -0.072729974985122681, 0.23246695101261139, -0.47013199329376221, 0.31344309449195862, 0.3596133291721344, 0.27669647336006165, -0.018113413825631142, 0.21217505633831024, 0.3774438202381134, -0.38413333892822266, -0.11083437502384186, 0.35245409607887268, 0.30135858058929443, 0.30140393972396851, 
  -0.52675968408584595, 0.38972193002700806, -0.077399052679538727, 0.46408674120903015, -0.08211091160774231, -0.52010279893875122, 0.19244897365570068, 0.41993606090545654, -0.31902691721916199, -0.31785130500793457, 0.55020612478256226, 0.44841107726097107, -0.22415271401405334, 0.37799736857414246, 0.09103761613368988, -0.18809743225574493, -0.18618664145469666, 0.27118885517120361, -0.31181767582893372, -0.13841958343982697, 
  0.25429832935333252, 0.26304841041564941, -0.056021418422460556, -0.49608397483825684, 0.26249918341636658, 0.33560338616371155, 0.11309313029050827, 0.094057425856590271, -0.15535075962543488, -0.051956318318843842, 0.21473598480224609, 0.18136464059352875, -0.32302811741828918, -0.18697081506252289, 0.13694579899311066, -0.13559865951538086, 0.21094955503940582, -0.097684562206268311, -0.093731008470058441, -0.16849614679813385, 
  0.31919986009597778, 0.47693586349487305, 0.055054929107427597, 0.45925545692443848, -0.10685407370328903, 0.3708159327507019, 0.35657614469528198, -0.52513659000396729, 0.61323648691177368, -0.18637970089912415, -0.35070458054542542, 0.35883378982543945, 0.34891274571418762, -0.16341871023178101, -0.58745187520980835, 0.11578131467103958, 0.33368358016014099, -0.025806868448853493, 0.017308240756392479, 0.24513845145702362, 
  0.60291743278503418, 0.22983336448669434, 0.075028188526630402, 0.13890516757965088, 0.44678351283073425, 0.33462917804718018, -0.47191774845123291, -0.1459118127822876, -0.028056180104613304, 0.089928857982158661, 0.12127404659986496, 0.046448681503534317, 0.14586059749126434, -0.73242902755737305, -0.26107582449913025, 0.4223429262638092, -0.035238135606050491, 0.27799046039581299, -0.14628209173679352, -0.040749579668045044, 
  0.23689040541648865, -0.36664363741874695, -0.099587202072143555, -0.096404924988746643, 0.38028380274772644, 0.39006450772285461, -0.14320552349090576, 0.0076091676019132137, 0.31678640842437744, -0.13514548540115356, -0.19059985876083374, 0.19340741634368896, -0.16629834473133087, -0.16717299818992615, 0.18775554001331329, 0.070152126252651215, -0.039400741457939148, 0.37119320034980774, 0.048455394804477692, 0.3840053379535675, 
};
const TfArray<2, int> tensor_dimension5 = { 2, { 10,20 } };
const ALIGN(16) float tensor_data6[4*10] = { 
  0.34886643290519714, 0.59039098024368286, 0.62206345796585083, -0.28253185749053955, 0.087062634527683258, -0.78611999750137329, -0.64905464649200439, -0.21293838322162628, 0.6776086688041687, 0.36765760183334351, 
  0.5304940938949585, -0.27232638001441956, -0.47577765583992004, -0.86283105611801147, -0.88826602697372437, -0.33729958534240723, -0.082716003060340881, 0.4058687686920166, 0.014043121598660946, 0.017851212993264198, 
  -0.74793261289596558, 0.43646767735481262, -0.42286473512649536, -0.61114686727523804, 0.47816452383995056, -0.72845917940139771, 0.68788015842437744, 0.28917470574378967, 0.41767483949661255, -0.4083387553691864, 
  -0.0068535888567566872, -0.28271350264549255, -0.036049392074346542, 0.53566586971282959, 0.28726524114608765, -0.10366590321063995, 0.42031905055046082, -0.34322983026504517, -0.97145611047744751, -0.62798887491226196, 
};
const TfArray<2, int> tensor_dimension6 = { 2, { 4,10 } };
const TfArray<2, int> tensor_dimension7 = { 2, { 1,20 } };
const TfArray<2, int> tensor_dimension8 = { 2, { 1,10 } };
const TfArray<2, int> tensor_dimension9 = { 2, { 1,4 } };
const TfArray<2, int> tensor_dimension10 = { 2, { 1,4 } };
const TfLiteFullyConnectedParams opdata0 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs0 = { 3, { 0,4,2 } };
const TfArray<1, int> outputs0 = { 1, { 7 } };
const TfLiteFullyConnectedParams opdata1 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs1 = { 3, { 7,5,1 } };
const TfArray<1, int> outputs1 = { 1, { 8 } };
const TfLiteFullyConnectedParams opdata2 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs2 = { 3, { 8,6,3 } };
const TfArray<1, int> outputs2 = { 1, { 9 } };
const TfLiteSoftmaxParams opdata3 = { 1 };
const TfArray<1, int> inputs3 = { 1, { 9 } };
const TfArray<1, int> outputs3 = { 1, { 10 } };
};

TensorInfo_t tensorData[] = {
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension0, 156, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data1, (TfLiteIntArray*)&g0::tensor_dimension1, 40, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data2, (TfLiteIntArray*)&g0::tensor_dimension2, 80, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data3, (TfLiteIntArray*)&g0::tensor_dimension3, 16, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data4, (TfLiteIntArray*)&g0::tensor_dimension4, 3120, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data5, (TfLiteIntArray*)&g0::tensor_dimension5, 800, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data6, (TfLiteIntArray*)&g0::tensor_dimension6, 160, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 160), (TfLiteIntArray*)&g0::tensor_dimension7, 80, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension8, 40, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 48), (TfLiteIntArray*)&g0::tensor_dimension9, 16, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension10, 16, },
};

#ifndef TF_LITE_STATIC_MEMORY
TfLiteNode tflNodes[4] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
};
#else
TfLiteNode tflNodes[4] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
};
#endif

used_operators_e used_ops[] =
{OP_FULLY_CONNECTED, OP_FULLY_CONNECTED, OP_FULLY_CONNECTED, OP_SOFTMAX, };


// Indices into tflTensors and tflNodes for subgraphs
const size_t tflTensors_subgraph_index[] = {0, 11, };
const size_t tflNodes_subgraph_index[] = {0, 4, };

// Input/output tensors
static const int in_tensor_indices[] = {
  0, 
};

static const int out_tensor_indices[] = {
  10, 
};


size_t current_subgraph_index = 0;

static void init_tflite_tensor(size_t i, TfLiteTensor *tensor) {
  tensor->type = kTfLiteFloat32;
  tensor->is_variable = false;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  tensor->allocation_type = tensorData[i].allocation_type;
#else
  tensor->allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
  tensor->bytes = tensorData[i].bytes;
  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  if(tensor->allocation_type == kTfLiteArenaRw){
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
      tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
  tensor->quantization.type = kTfLiteNoQuantization;

}

static void init_tflite_eval_tensor(int i, TfLiteEvalTensor *tensor) {

  tensor->type = kTfLiteFloat32;

  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  auto allocation_type = tensorData[i].allocation_type;
  if(allocation_type == kTfLiteArenaRw) {
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
    tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
}

static void* overflow_buffers[EI_MAX_OVERFLOW_BUFFER_COUNT];
static size_t overflow_buffers_ix = 0;
static void * AllocatePersistentBufferImpl(struct TfLiteContext* ctx,
                                       size_t bytes) {
  void *ptr;
  uint32_t align_bytes = (bytes % 16) ? 16 - (bytes % 16) : 0;

  if (current_location - (bytes + align_bytes) < tensor_boundary) {
    if (overflow_buffers_ix > EI_MAX_OVERFLOW_BUFFER_COUNT - 1) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d, does not fit in tensor arena and reached EI_MAX_OVERFLOW_BUFFER_COUNT\n",
        (int)bytes);
      return NULL;
    }

    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    ptr = ei_calloc(bytes, 1);
    if (ptr == NULL) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return NULL;
    }
    overflow_buffers[overflow_buffers_ix++] = ptr;
    return ptr;
  }

  current_location -= bytes;

  // align to the left aligned boundary of 16 bytes
  current_location -= 15; // for alignment
  current_location += 16 - ((uintptr_t)(current_location) & 15);

  ptr = current_location;
  memset(ptr, 0, bytes);

  return ptr;
}

typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;

static scratch_buffer_t scratch_buffers[EI_MAX_SCRATCH_BUFFER_COUNT];
static size_t scratch_buffers_ix = 0;

static TfLiteStatus RequestScratchBufferInArenaImpl(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  if (scratch_buffers_ix > EI_MAX_SCRATCH_BUFFER_COUNT - 1) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d, reached EI_MAX_SCRATCH_BUFFER_COUNT\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffer_t b;
  b.bytes = bytes;

  b.ptr = AllocatePersistentBufferImpl(ctx, b.bytes);
  if (!b.ptr) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffers[scratch_buffers_ix] = b;
  *buffer_idx = scratch_buffers_ix;

  scratch_buffers_ix++;

  return kTfLiteOk;
}

static void* GetScratchBufferImpl(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > (int)scratch_buffers_ix) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}

static const uint16_t TENSOR_IX_UNUSED = 0x7FFF;

static void ResetTensors() {
  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    tflTensors[ix].index = TENSOR_IX_UNUSED;
  }
  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    tflEvalTensors[ix].index = TENSOR_IX_UNUSED;
  }
}

static TfLiteTensor* GetTensorImpl(const struct TfLiteContext* context,
                               int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    // already used? OK!
    if (tflTensors[ix].index == tensor_idx) {
      return &tflTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_tensor(tensor_idx, &tflTensors[ix].tensor);
      tflTensors[ix].index = tensor_idx;
      return &tflTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_TENSOR_COUNT (%d)\n", MAX_TFL_TENSOR_COUNT);
  return nullptr;
}

static TfLiteEvalTensor* GetEvalTensorImpl(const struct TfLiteContext* context,
                                       int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    // already used? OK!
    if (tflEvalTensors[ix].index == tensor_idx) {
      return &tflEvalTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflEvalTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_eval_tensor(tensor_idx, &tflEvalTensors[ix].tensor);
      tflEvalTensors[ix].index = tensor_idx;
      return &tflEvalTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_EVAL_COUNT (%d)\n", (int)MAX_TFL_EVAL_COUNT);
  return nullptr;
}

class EonMicroContext : public MicroContext {
 public:
 
  EonMicroContext(): MicroContext(nullptr, nullptr, nullptr) { }

  void* AllocatePersistentBuffer(size_t bytes) {
    return AllocatePersistentBufferImpl(nullptr, bytes);
  }

  TfLiteStatus RequestScratchBufferInArena(size_t bytes,
                                           int* buffer_index) {
  return RequestScratchBufferInArenaImpl(nullptr, bytes, buffer_index);
  }

  void* GetScratchBuffer(int buffer_index) {
    return GetScratchBufferImpl(nullptr, buffer_index);
  }
 
  TfLiteTensor* AllocateTempTfLiteTensor(int tensor_index) {
    return GetTensorImpl(nullptr, tensor_index);
  }

  void DeallocateTempTfLiteTensor(TfLiteTensor* tensor) {
    return;
  }

  bool IsAllTempTfLiteTensorDeallocated() {
    return true;
  }

  TfLiteEvalTensor* GetEvalTensor(int tensor_index) {
    return GetEvalTensorImpl(nullptr, tensor_index);
  }

};


} // namespace

TfLiteStatus tflite_learn_20_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    ei_printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#else
  memset(tensor_arena, 0, kTensorArenaSize);
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;

  EonMicroContext micro_context_;
  
  // Set microcontext as the context ptr
  ctx.impl_ = static_cast<void*>(&micro_context_);
  // Setup tflitecontext functions
  ctx.AllocatePersistentBuffer = &AllocatePersistentBufferImpl;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArenaImpl;
  ctx.GetScratchBuffer = &GetScratchBufferImpl;
  ctx.GetTensor = &GetTensorImpl;
  ctx.GetEvalTensor = &GetEvalTensorImpl;
  ctx.ReportError = &MicroContextReportOpError;

  ctx.tensors_size = 11;
  for (size_t i = 0; i < 11; ++i) {
    TfLiteTensor tensor;
    init_tflite_tensor(i, &tensor);
    if (tensor.allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tensor.data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }

  if (tensor_boundary > current_location /* end of arena size */) {
    ei_printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }

  registrations[OP_FULLY_CONNECTED] = Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = Register_SOFTMAX();

  for (size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].init) {
        tflNodes[i].user_data = registrations[used_ops[i]].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
      }
    }
  }
  current_subgraph_index = 0;

  for(size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].prepare) {
        ResetTensors();
        TfLiteStatus status = registrations[used_ops[i]].prepare(&ctx, &tflNodes[i]);
        if (status != kTfLiteOk) {
          return status;
        }
      }
    }
  }
  current_subgraph_index = 0;

  return kTfLiteOk;
}

TfLiteStatus tflite_learn_20_input(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(in_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_20_output(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(out_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_20_invoke() {
  for (size_t i = 0; i < 4; ++i) {
    ResetTensors();

    TfLiteStatus status = registrations[used_ops[i]].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_20_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif

  // scratch buffers are allocated within the arena, so just reset the counter so memory can be reused
  scratch_buffers_ix = 0;

  // overflow buffers are on the heap, so free them first
  for (size_t ix = 0; ix < overflow_buffers_ix; ix++) {
    ei_free(overflow_buffers[ix]);
  }
  overflow_buffers_ix = 0;
  return kTfLiteOk;
}
